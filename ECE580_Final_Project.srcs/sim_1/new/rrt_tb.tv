//////////////////////////////////////////////////////////////////////////////////

// Create Date: 11/12/2025 09:48:23 PM
// Design Name: 
// Module Name: testbench
// Project Name: 
// Reference: https://fpgatutorial.com/how-to-write-a-basic-verilog-testbench/

//////////////////////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module rrt_tb();

localparam COORDINATE_WIDTH = 10;
localparam NUM_PE = 5;
localparam NUM_PE_WIDTH = 3;
localparam N = 1024;
localparam N_SQUARED = N * N;
localparam N_BITS = 10;
localparam OUTERMOST_ITER_MAX = 1024;
localparam OUTERMOST_ITER_BITS = 10;
localparam COST_WIDTH = 16;
localparam ADDR_BITS = 20;

reg clk;
reg reset;

// Start and goal points
reg [COORDINATE_WIDTH-1:0] start_x;
reg [COORDINATE_WIDTH-1:0] start_y;
reg [COORDINATE_WIDTH-1:0] goal_top_bound;
reg [COORDINATE_WIDTH-1:0] goal_bottom_bound;
reg [COORDINATE_WIDTH-1:0] goal_left_bound;
reg [COORDINATE_WIDTH-1:0] goal_right_bound;

// Obstacle data inputs
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_left;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_right;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_top;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_bottom;

// Status outputs
wire path_found;

// Exposed states
wire failure_state;
wire traceback_state;

// core connects our datapath to controller
core #(
    .COORDINATE_WIDTH(COORDINATE_WIDTH),
    .NUM_PE(NUM_PE),
    .NUM_PE_WIDTH(NUM_PE_WIDTH),
    .N(N),
    .N_SQUARED(N_SQUARED),
    .N_BITS(N_BITS),
    .OUTERMOST_ITER_MAX(OUTERMOST_ITER_MAX),
    .OUTERMOST_ITER_BITS(OUTERMOST_ITER_BITS),
    .COST_WIDTH(COST_WIDTH),
    .ADDR_BITS(ADDR_BITS)
) dut (
    .clk(clk),
    .reset(reset),
    .start_x(start_x),
    .start_y(start_y),
    .goal_top_bound(goal_top_bound),
    .goal_bottom_bound(goal_bottom_bound),
    .goal_left_bound(goal_left_bound),
    .goal_right_bound(goal_right_bound),
    .obs_left(obs_left),
    .obs_right(obs_right),
    .obs_top(obs_top),
    .obs_bottom(obs_bottom),
    .path_found(path_found)
);

// clock
initial begin
    clk = 1'b0;
    forever begin
    #5 clk = ~clk;
    end
end

// reset
initial begin
    reset = 1'b1;
    #10
    reset = 1'b0;
end

// initialize all the inputs
initial begin    
    start_x = {COORDINATE_WIDTH{1'b0}}; // start at (0,0)
    start_y = {COORDINATE_WIDTH{1'b0}};
    
    goal_top_bound = 1023 - 10; // make the goal box 10x10 in the opposite corner
    goal_bottom_bound = 1023;
    goal_left_bound = 1023 - 10;
    goal_right_bound = 1023;

    obs_left = { 10'd1022, 10'd1022, 10'd1022, 10'd1022, 10'd1022}; // start by making the obstacles all the same, putting them in the upper right corner and small
    obs_right = { 10'd1023, 10'd1023, 10'd1023, 10'd1023, 10'd1023};
    obs_top = { 10'd0, 10'd0, 10'd0, 10'd0, 10'd0};
    obs_bottom = { 10'd1, 10'd1, 10'd1, 10'd1, 10'd1};
end

// on each clock edge just figure if we got to the final states yet
always @( posedge clk) begin
    if ( failure_state == 1'b1 || traceback_state == 1'b1 ) begin
        $display("time: %0t", $time);
        $display("path_found: %b", path_found);
        #5 $finish;
    end
end

endmodule