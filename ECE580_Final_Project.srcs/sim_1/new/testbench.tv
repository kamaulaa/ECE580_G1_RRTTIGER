//////////////////////////////////////////////////////////////////////////////////

// Create Date: 11/12/2025 09:48:23 PM
// Design Name: 
// Module Name: testbench.tv
// Project Name: 
// Reference: https://fpgatutorial.com/how-to-write-a-basic-verilog-testbench/

//////////////////////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module testbench;

parameter COORDINATE_WIDTH = 10;
parameter NUM_PE = 5;
parameter NUM_PE_WIDTH = 3;
parameter N = 1024;
parameter N_SQUARED = N * N;
parameter N_BITS = 10;
parameter OUTERMOST_ITER_MAX = 1024;
parameter OUTERMOST_ITER_BITS = 10;
parameter COST_WIDTH = 16;
parameter ADDR_BITS = 20;

reg clk;
reg reset;

// Start and goal points
reg [COORDINATE_WIDTH-1:0] start_x;
reg [COORDINATE_WIDTH-1:0] start_y;
reg [COORDINATE_WIDTH-1:0] goal_top_bound;
reg [COORDINATE_WIDTH-1:0] goal_bottom_bound;
reg [COORDINATE_WIDTH-1:0] goal_left_bound;
reg [COORDINATE_WIDTH-1:0] goal_right_bound;

// Obstacle data inputs
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_left;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_right;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_top;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_bottom;

// Status outputs
wire path_found;

// Exposed states
wire failure_state;
wire traceback_state;
wire[3:0] output_state;
wire random_point_already_exists;
wire [9:0] xrand_wire;
wire [9:0] yrand_wire;
wire [9:0] occupied_array_currentidx;
wire current_array_entry_same_asrandom;
wire [9:0] occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB;
wire [9:0] occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB;
wire x_equal;
wire y_equal;  

wire done_detecting_new_point_q_collision;
wire new_point_qcollided;
wire [4:0] total_draincycles;
wire [4:0] detecting_new_point_q_collision_cyclecount;

wire entering_check_steered_point;
wire steered_point_in_obstacle; 
wire done_checking_steeredpoint;
wire [NUM_PE_WIDTH:0] steered_point_check_cyclecount;

wire [3:0] nearest_neighborcount;
wire entering_search_nearestneighbor;
wire searchneighbor;

core #(
    .COORDINATE_WIDTH(COORDINATE_WIDTH),
    .NUM_PE(NUM_PE),
    .NUM_PE_WIDTH(NUM_PE_WIDTH),
    .N(N),
    .N_SQUARED(N_SQUARED),
    .N_BITS(N_BITS),
    .OUTERMOST_ITER_MAX(OUTERMOST_ITER_MAX),
    .OUTERMOST_ITER_BITS(OUTERMOST_ITER_BITS),
    .COST_WIDTH(COST_WIDTH),
    .ADDR_BITS(ADDR_BITS)
) dut (
    .clk(clk),
    .reset(reset),
    .start_x(start_x),
    .start_y(start_y),
    .goal_top_bound(goal_top_bound),
    .goal_bottom_bound(goal_bottom_bound),
    .goal_left_bound(goal_left_bound),
    .goal_right_bound(goal_right_bound),
    .obs_left(obs_left),
    .obs_right(obs_right),
    .obs_top(obs_top),
    .obs_bottom(obs_bottom),
    .path_found(path_found),
    .failure_state(failure_state),
    .traceback_state(traceback_state),
    .output_state(output_state),
    .generate_req(generate_req),
    .random_point_already_exists(random_point_already_exists),
    .xrand_wire(xrand_wire),
    .yrand_wire(yrand_wire),
    .occupied_array_currentidx(occupied_array_currentidx),
    .current_array_entry_same_asrandom(current_array_entry_same_asrandom),
    .occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB(occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB),
    .occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB(occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB),
    .x_equal(x_equal),
    .y_equal(y_equal),
    
    .done_detecting_new_point_q_collision(done_detecting_new_point_q_collision),
    .new_point_qcollided(new_point_qcollided),
    .total_draincycles(total_draincycles),
    .detecting_new_point_q_collision_cyclecount(detecting_new_point_q_collision_cyclecount),
    
    .entering_check_steered_point(entering_check_steered_point),
    .steered_point_in_obstacle(steered_point_in_obstacle),    
    .done_checking_steeredpoint(done_checking_steeredpoint),
    .steered_point_check_cyclecount(steered_point_check_cyclecount),
    
    .nearest_neighborcount(nearest_neighborcount),
    .searchneighbor(searchneighbor),
    .entering_search_nearestneighbor(entering_search_nearestneighbor)

);

// clock
//initial begin
//    clk = 1'b0;
//    forever #5 clk = ~clk;
//end

initial clk = 1'b0;
always
#10 clk = ~clk;

// reset
initial begin
    reset = 1'b1;
    @(posedge clk);
    @(posedge clk); 
    reset = 1'b0;
end

// initialize all the inputs
initial begin    
    start_x = {COORDINATE_WIDTH{1'b0}}; // start at (0,0)
    start_y = {COORDINATE_WIDTH{1'b0}};
    
    goal_top_bound = 1023 - 10; // make the goal box 10x10 in the opposite corner
    goal_bottom_bound = 1023;
    goal_left_bound = 1023 - 10;
    goal_right_bound = 1023;

    obs_left = { 10'd1022, 10'd1022, 10'd1022, 10'd1022, 10'd1022}; // start by making the obstacles all the same, putting them in the upper right corner and small
    obs_right = { 10'd1023, 10'd1023, 10'd1023, 10'd1023, 10'd1023};
    obs_top = { 10'd0, 10'd0, 10'd0, 10'd0, 10'd0};
    obs_bottom = { 10'd1, 10'd1, 10'd1, 10'd1, 10'd1};
end

//forever begin
//    // on each clock edge just figure if we got to the final states yet
//    always @( posedge clk) begin
//        if ( failure_state == 1'b1 || traceback_state == 1'b1 ) begin
//            $display("time: %0t", $time);
//            $display("path_found: %b", path_found);
//            #5 $finish;
//        end
//    end
//end

initial begin
    forever begin @(posedge clk);
        if (failure_state || traceback_state) begin
            $display("time: %0t", $time);
            $display("path_found: %b", path_found);
            $finish;
        end
    end
end



always @(posedge clk) begin
    $display("t=%0t | failure=%b traceback=%b path_found=%b", $time, failure_state, traceback_state, path_found);
end


endmodule