//////////////////////////////////////////////////////////////////////////////////

// Create Date: 11/12/2025 09:48:23 PM
// Design Name: 
// Module Name: testbench.tv
// Project Name: 
// Reference: https://fpgatutorial.com/how-to-write-a-basic-verilog-testbench/

//////////////////////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module testbench;

parameter COORDINATE_WIDTH = 7;
parameter NUM_PE = 5;
parameter NUM_PE_WIDTH = 3;
parameter N = 128;
parameter N_SQUARED = N * N;
parameter N_BITS = 7;
parameter OUTERMOST_ITER_MAX = 4095; // lauren: 1023
parameter OUTERMOST_ITER_BITS = 12; // lauren: 10
parameter COST_WIDTH = 16; // change the cost width
parameter ADDR_BITS = 14;

reg clk;
reg reset;

// Start and goal points
reg [COORDINATE_WIDTH-1:0] start_x;
reg [COORDINATE_WIDTH-1:0] start_y;
reg [COORDINATE_WIDTH-1:0] goal_top_bound;
reg [COORDINATE_WIDTH-1:0] goal_bottom_bound;
reg [COORDINATE_WIDTH-1:0] goal_left_bound;
reg [COORDINATE_WIDTH-1:0] goal_right_bound;

// Obstacle data inputs
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_left;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_right;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_top;
reg [NUM_PE*COORDINATE_WIDTH-1:0] obs_bottom;

// Status outputs
wire path_found;

//// Exposed states
//wire failure_state;
//wire traceback_state;

wire[3:0] output_state;
//wire random_point_already_exists;
//wire [COORDINATE_WIDTH-1:0] xrand_wire;
//wire [COORDINATE_WIDTH-1:0] yrand_wire;
//wire [COORDINATE_WIDTH-1:0] occupied_array_currentidx;
//wire current_array_entry_same_asrandom;
//wire [COORDINATE_WIDTH-1:0] occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB;
//wire [COORDINATE_WIDTH-1:0] occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB;
//wire x_equal;
//wire y_equal;  

wire done_detecting_new_point_q_collision;
//wire new_point_qcollided;
//wire [4:0] total_draincycles;
//wire [4:0] detecting_new_point_q_collision_cyclecount;

wire entering_check_steered_point;
wire steered_point_in_obstacle; 
//wire done_checking_steeredpoint;
//wire [NUM_PE_WIDTH:0] steered_point_check_cyclecount;

//wire [3:0] nearest_neighborcount;
//wire entering_search_nearestneighbor;
//wire searchneighbor;

//wire systolic_validout;
//wire systolic_validpair;

//wire [OUTERMOST_ITER_BITS-1:0] outermost_loopcounter;
wire check_steered_point;
wire check_new_point_q_collision;

//wire update_minpoint;
//wire systolic_valid_pairq;
//wire [COST_WIDTH-1:0] rdcost;
//wire [COST_WIDTH-1:0] calculatedcost;
//wire [COST_WIDTH-1:0] totalcost;
//wire validin;

//wire [COORDINATE_WIDTH-1:0] systolic_valx1;
//wire [COORDINATE_WIDTH-1:0] systolic_valy1;
//wire [COORDINATE_WIDTH-1:0] systolic_valx2;
//wire [COORDINATE_WIDTH-1:0] systolic_valy2;
//wire [COORDINATE_WIDTH-1:0] systolic_val_parentindex;

//wire [COORDINATE_WIDTH-1:0] new_pointx;
//wire [COORDINATE_WIDTH-1:0] new_pointy;    
       
wire add_new_point_q;

//wire [COORDINATE_WIDTH-1:0] new_point_parentx;
//wire [COORDINATE_WIDTH-1:0] new_point_parenty;  

//wire [OUTERMOST_ITER_BITS-1:0] best_neighboridx;

wire search_neighbor;
wire done_with_search_nearest_neighbor;
//wire [COORDINATE_WIDTH-1:0] potential_new_pointx;
//wire [COORDINATE_WIDTH-1:0] potential_new_pointy;

//wire [OUTERMOST_ITER_BITS-1:0] occupied_arrayidx;
wire add_edge_state;
wire entering_check_new_point_q_collision;

//wire outermost_loopcheck;
//wire outermost_counter_less_than;

wire [COST_WIDTH-1:0] finalcost; // this stays the same during traceback, it's always the cost of the last element added
wire [COORDINATE_WIDTH-1:0] final_xcoord; // this changes each cycle of traceback
wire [COORDINATE_WIDTH-1:0] final_ycoord; // this changes each cycle of traceback

wire [OUTERMOST_ITER_BITS-1:0] tracebackptr;
wire [OUTERMOST_ITER_BITS-1:0] new_tracebackptr;

//wire goalreached;

//wire [COORDINATE_WIDTH-1:0] systolic_val_x1q;
//wire [COORDINATE_WIDTH-1:0] systolic_val_y1q;

//wire [COST_WIDTH-1:0] cmin;
//wire [OUTERMOST_ITER_BITS-1:0] systolic_val_parent_indexq;

//wire [COORDINATE_WIDTH-1:0] nbx; // coords of that nearest neighbor
//wire [COORDINATE_WIDTH-1:0] nby;
//wire [OUTERMOST_ITER_BITS-1:0] nbindex;

wire generate_req;
wire do_traceback;

core #(
    .COORDINATE_WIDTH(COORDINATE_WIDTH),
    .NUM_PE(NUM_PE),
    .NUM_PE_WIDTH(NUM_PE_WIDTH),
    .N(N),
    .N_SQUARED(N_SQUARED),
    .N_BITS(N_BITS),
    .OUTERMOST_ITER_MAX(OUTERMOST_ITER_MAX),
    .OUTERMOST_ITER_BITS(OUTERMOST_ITER_BITS),
    .COST_WIDTH(COST_WIDTH),
    .ADDR_BITS(ADDR_BITS)
) dut (
    .clk(clk),
    .reset(reset),
    .start_x(start_x),
    .start_y(start_y),
    .goal_top_bound(goal_top_bound),
    .goal_bottom_bound(goal_bottom_bound),
    .goal_left_bound(goal_left_bound),
    .goal_right_bound(goal_right_bound),
    .obs_left(obs_left),
    .obs_right(obs_right),
    .obs_top(obs_top),
    .obs_bottom(obs_bottom),
    .path_found(path_found),
    
//    .failure_state(failure_state),
//    .traceback_state(traceback_state),
    .output_state(output_state),
    .generate_req(generate_req),
    .random_point_already_exists(random_point_already_exists),
//    .xrand_wire(xrand_wire),
//    .yrand_wire(yrand_wire),
//    .occupied_array_currentidx(occupied_array_currentidx),
//    .current_array_entry_same_asrandom(current_array_entry_same_asrandom),
//    .occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB(occupied_points_array_occupied_array_current_idx_X_MSB_X_LSB),
//    .occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB(occupied_points_array_occupied_array_current_idx_Y_MSB_Y_LSB),
//    .x_equal(x_equal),
//    .y_equal(y_equal),
    
    .done_detecting_new_point_q_collision(done_detecting_new_point_q_collision),
//    .new_point_qcollided(new_point_qcollided),
//    .total_draincycles(total_draincycles),
//    .detecting_new_point_q_collision_cyclecount(detecting_new_point_q_collision_cyclecount),
    
    .entering_check_steered_point(entering_check_steered_point),
    .steered_point_in_obstacle(steered_point_in_obstacle),    
//    .done_checking_steeredpoint(done_checking_steeredpoint),
//    .steered_point_check_cyclecount(steered_point_check_cyclecount),
    
    .nearest_neighborcount(nearest_neighborcount),
//    .searchneighbor(searchneighbor),
//    .entering_search_nearestneighbor(entering_search_nearestneighbor),
    
//    .systolic_validout(systolic_validout),
//    .systolic_validpair(systolic_validpair),
    
//    .outermost_loopcounter(outermost_loopcounter),
    .check_steered_point(check_steered_point),
    .check_new_point_q_collision(check_new_point_q_collision),
    
//    .update_minpoint(update_minpoint),
//    .systolic_valid_pairq(systolic_valid_pairq),
//    .rdcost(rdcost),
//    .calculatedcost(calculatedcost),
//    .totalcost(totalcost),
    
//    .validin(validin),
    
//    .systolic_valx1(systolic_valx1),
//    .systolic_valy1(systolic_valy1),
//    .systolic_valx2(systolic_valx2),
//    .systolic_valy2(systolic_valy2),
//    .systolic_val_parentindex(systolic_val_parentindex),
    
//    .new_pointx(new_pointx),
//    .new_pointy(new_pointy),
    
    .add_new_point_q(add_new_point_q),
    
//    .new_point_parentx(new_point_parentx),
//    .new_point_parenty(new_point_parenty),
//    .best_neighboridx(best_neighboridx),
    
    .search_neighbor(search_neighbor),
    .done_with_search_nearest_neighbor(done_with_search_nearest_neighbor),
//    .potential_new_pointx(potential_new_pointx),
//    .potential_new_pointy(potential_new_pointy),
    
//    .occupied_arrayidx(occupied_arrayidx),
    .add_edge_state(add_edge_state),
    .entering_check_new_point_q_collision(entering_check_new_point_q_collision),
    .do_traceback(do_traceback),
    
    .finalcost(finalcost),
    .final_xcoord(final_xcoord),
    .final_ycoord(final_ycoord),
    .tracebackptr(tracebackptr),
    .new_tracebackptr(new_tracebackptr)
    
//    .outermost_loopcheck(outermost_loopcheck),    
//    .outermost_counter_less_than(outermost_counter_less_than),
    
//    .goalreached(goalreached),
    
//    .systolic_val_x1q(systolic_val_x1q),
//    .systolic_val_y1q(systolic_val_y1q),
//    .cmin(cmin),
//    .systolic_val_parent_indexq(systolic_val_parent_indexq),
    
//    .nbx(nbx),
//    .nby(nby),
//    .nbindex(nbindex)

);

integer cycles;


initial clk = 1'b0;
always
#7.5 clk = ~clk;
//#10 clk = ~clk;

// reset
initial begin
    reset = 1'b1;
    @(posedge clk);
    @(posedge clk); 
    reset = 1'b0;
    cycles = 0;
end

// lauren - added this - make sure to remove
integer occ_file;
integer i;
reg printed_once;
initial begin
    printed_once = 0;
    occ_file = $fopen("occupied_points_dump_test_4.txt", "w");
    if (occ_file == 0) begin
        $display("ERROR: could not open occupied_points_dump.txt");
        $finish;
    end
end

// initialize all the inputs
initial begin  

    start_x = 10'd111;  // Inside the goal box
    start_y = 10'd15;
    
    // Goal region: 10x10 box in upper-right corner
    goal_top_bound    = 10;
    goal_bottom_bound = 20;
    goal_left_bound   = 116-10;
    goal_right_bound  = 116;
    
    // No obstacles needed - overlapped in top right corner
    obs_left    =   { 7'd126,   7'd126, 7'd126, 7'd126, 7'd126};
    obs_right   =   { 7'd127,   7'd127, 7'd127, 7'd127, 7'd127};
    obs_top     =   { 7'd0,     7'd0,   7'd0,   7'd0,   7'd0};
    obs_bottom  =   { 7'd1,     7'd1,   7'd1,   7'd1,   7'd1};
    

end

initial begin
    forever begin @(posedge clk);
        cycles = cycles + 1;

        // Dump array if path found, path failed, or timeout
        if (!printed_once && 
            (output_state == 4'b1000 || output_state == 4'b1001 || cycles >= 100000)) begin
            printed_once = 1;

            $fdisplay(occ_file, "Occupied points array dump at time %0t", $time);
            for (i = 0; i < 4096; i = i + 1) begin
                $fdisplay(occ_file,
                    "[%0d] = %h",
                    i,
                    dut.datapath_inst.occupied_points_array[i]  // adjust hierarchy if needed
                );
            end
            $fdisplay(occ_file, "---- end dump ----\n");
            $fflush(occ_file);
            $display("Occupied points array written to file.");
        end

        // Debug messages
        if (output_state == 4'b1000) begin
            $display("time: %0t", $time);
            $display("path not found");
        end else if (output_state == 4'b1001) begin
            $display("time: %0t", $time);
            $display("path found");
        end

        // Finish simulation if either path finished or timeout
        if (output_state == 4'b1010 || cycles >= 3860000) begin
            $display("cycles: %0d", cycles);
            $fflush(occ_file);
            $fclose(occ_file);
            $display("File closed. Simulation finished.");
            $finish;
        end
    end
end

endmodule
